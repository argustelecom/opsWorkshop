package ru.argustelecom.box.env.billing.subscription.accounting;

import static java.util.Collections.singletonList;

import java.io.Serializable;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;

import ru.argustelecom.box.env.billing.invoice.model.LongTermInvoice;
import ru.argustelecom.box.env.billing.subscription.accounting.impl.InvoicePlannerCase;
import ru.argustelecom.box.env.billing.subscription.model.Subscription;
import ru.argustelecom.box.env.privilege.discount.model.Discount;
import ru.argustelecom.box.env.privilege.model.Privilege;

/**
 * Единый фасад для функциональности расчетов периодических списаний для подписки
 */
public interface SubscriptionAccountingService extends Serializable {

	/**
	 * Расчитывает план на следующий период тарификации указанной подписки. Перед расчетом определит гарантированно
	 * последний инвойс для указанной подписки и делегирует дальнейшее вычисление
	 * {@linkplain #calculateNextAccruals(Subscription, LongTermInvoice, Date)}
	 * 
	 * @param subscription
	 *            - тарифицируемая подписка. Обязательный параметр
	 * @param calculationDate
	 *            - дата расчета. Обязательный параметр
	 * 
	 * @return расчитанный план или null (если дальнейшая тарификация не предполагается)
	 */
	InvoicePlan calculateNextAccruals(Subscription subscription, Date calculationDate);

	/**
	 * Расчитывает план на следующий период тарификации указанной подписки. Использует переданный lastInvoice для
	 * определения пересчечения границ и для определения кейса планирования. ВЕРИТ, что переданный инвойс действительно
	 * последний для указанной подписки (если это не так, то вызывающий сам себе злобный буратино).
	 * <p>
	 * Может вернуть null, но только в том случае, если подписка не нуждается больше в тарификации, например, если она
	 * закрыта или ожидает закрытия. Во всех остальных случаях вернет либо расчитанный новый план, либо бросит
	 * соответствующее исключение.
	 * <p>
	 * Этот метод автоматически определяет привилегии и скидки, потенциально применимые для текущего расчета. Для этого
	 * определяется {@linkplain InvoicePlannerCase кейс планирования} и по этому сценарию определяется дата начала
	 * планирования. От этой даты вычисляется текущий период списания и границы этого периода используются для поиска
	 * привилегий и скидок. Таким образом гарантируется, что модификаторы, требуемые для расчета, найдутся, если они
	 * вообще есть.
	 * 
	 * @param subscription
	 *            - тарифицируемая подписка. Обязательный параметр
	 * @param lastInvoice
	 *            - последний инвойс тарифицируемой подписки. Может отсутствовать, но только в том случае, если
	 *            тарификации еще не было (оформление, ожидает активации, приостановлено за неуплату из активации)
	 * @param calculationDate
	 *            - дата расчета, обязательный параметр
	 * 
	 * @return расчитанный план или null (если дальнейшая тарификация не предполагается)
	 */
	InvoicePlan calculateNextAccruals(Subscription subscription, LongTermInvoice lastInvoice, Date calculationDate);

	/**
	 * Шоткат метода {@linkplain #calculateBillAccruals(List, Date, Date, Date)} для одной подписки
	 * 
	 * @param subscription
	 *            - тарифицируемая подписка. Обязательный параметр
	 * @param startDate
	 *            - дата начала интереса для планирования. Обязательный параметр
	 * @param endDate
	 *            - дата окончания интереса для планирования. Обязательный параметр
	 * @param renewalDate
	 *            - дата предполагаемого возобновления тарификации в случае, если подписка была приостановлена и
	 *            находится в нетарифицируемом состоянии
	 * 
	 * @return планы восстановленные за прошлые периоды и сгенерированные для будущих периодов для указанной
	 *         тарифицируемой подписки или пустой список, если тарификация не предполагается
	 */
	default List<InvoicePlan> calculateBillAccruals(Subscription subscription, Date startDate, Date endDate,
			Date renewalDate) {

		List<Subscription> subs = singletonList(subscription);
		Map<Subscription, List<InvoicePlan>> accruals = calculateBillAccruals(subs, startDate, endDate, renewalDate);
		return accruals.getOrDefault(subscription, Collections.emptyList());
	}

	/**
	 * <strong>Для каждой подписки из указанных:</strong> Восстанавливает планы за предыдущие периоды для подписки и
	 * расчитывает планы на будущее. Игнорирует подписку, если она находится в терминальном статусе или в статусе
	 * оформления (но не в ожидании при отложенной активации)
	 * <p>
	 * Расчет обязательно должен быть ограничен каким-либо периодом. Важно понимать, что этот период не является
	 * абсолютным, т.е. планы не лимитируются им. Например, если подписка предоставляется по условиям с календарным
	 * периодом и ежемесячными списаниями (Tc1 [01.01.2018 00:00:00 - 31.01.2018 23:59:59], Tc2 [01.02.2018 00:00:00 -
	 * 27.02.2018 23:59:59]), а указаные даты startDate и endDate приходятся на середину месяца (15.01.2018 -
	 * 15.02.2018), то в результирующий список попадут оба плана для Tc1 и Tc2, т.к. их периоды пересекаются с указанным
	 * периодом интереса. Какой из пограничных планов учитывать в дальнейшем - задача вызывающего этот метод.
	 * <p>
	 * Если в указанный период интереса для подписки действуют привилегии и скидки, они также будут учтены в расчете, и
	 * коллекция планов будет содержать значения, построенные в соответствии с этими модификаторами. Например, для
	 * одного периода списания может быть сгенерировано несколько планов (из-за влияния доверительного или тестового
	 * периодов) и т.д.
	 * <p>
	 * Также в этом методе учитывается дата окончания действия подписки, за которой планов нет и быть не может, т.к.
	 * подписка перейдет в свое терминальное состояние. Планы не обязательно будут следовать непрерывно, возможны
	 * интервалы, в которых не было тарификации (приостановленная подписка). Результат также может содержать планы
	 * только за предыдущие периоды, без будущих планов (ретроспектива в прошлое при постоплатной схеме)
	 * <p>
	 * Особое внимание необходимо уделить параметру renewalDate. Он используется в том случае, если подписка находится в
	 * нетарифицируемом, но не в терминальном состоянии, и означает дату, с которой предполагается возобновить
	 * тарификацию этой подписки. Если этот параметр не будет указан, то возобновление станет невозможным, т.е. мы не
	 * сможем определить дату, с которой нужно возобновить тарификацию.
	 * 
	 * @param subscriptions
	 *            - список тарифицируемых подписок. Обязательный параметр
	 * @param startDate
	 *            - дата начала интереса для планирования. Обязательный параметр
	 * @param endDate
	 *            - дата окончания интереса для планирования. Обязательный параметр
	 * @param renewalDate
	 *            - дата предполагаемого возобновления тарификации в случае, если подписка была приостановлена и
	 *            находится в нетарифицируемом состоянии
	 * 
	 * @return коллекцию предполагаемых планов для указанного периода интереса. Может быть пустой, если тарификация для
	 *         подписки не предполагается
	 */
	Map<Subscription, List<InvoicePlan>> calculateBillAccruals(List<Subscription> subscriptions, Date startDate,
			Date endDate, Date renewalDate);

	/**
	 * Простой перерасчет указанного инвойса. При перерасчете сохраняются все привязки к скидкам, привилегиям и прочим
	 * модификаторам.
	 * <p>
	 * Полезно использовать в том случае, если каким либо образом изменились параметры связанных объектов, например,
	 * размер скидки.
	 * <p>
	 * Состояние инвойса при пересчете не меняется. Для применения нового плана к инвойсу необходимо явно вызвать метод
	 * {@link LongTermInvoice#applyPlan(InvoicePlan)}. Пересчитать можно только открытый инвойс
	 * 
	 * @param invoice
	 *            - инвойс для пересчета
	 * 
	 * @return новый план. Всегда не null
	 */
	InvoicePlan recalculate(LongTermInvoice invoice);

	/**
	 * Расчет досрочного закрытия для указанного инвойса. Если дата досрочного закрытия не отличается от плановой даты
	 * закрытия инвойса, но расчет не требуется и метод вернет null. Дата досрочного закрытия должна быть меньше
	 * планируемой даты закрытия инвойса, при этом дата досрочного закрытия должна попадать в период инвойса. Если это
	 * утверждение не выполняется, то будет спровоцировано исключение.
	 * <p>
	 * Полезно использовать при досрочном закрытии инвойса вследствие изменения статуса подписки или при досрочном
	 * закрытии привилегии
	 * <p>
	 * Состояние инвойса при пересчете не меняется. Для применения нового плана к инвойсу необходимо явно вызвать метод
	 * {@link LongTermInvoice#applyPlan(InvoicePlan)}. Пересчитать можно только открытый инвойс
	 * 
	 * @param invoice
	 *            - инвойс для пересчета
	 * @param closeDate
	 *            - дата досрочного закрытия
	 * 
	 * @return новый план. Или null, если пересчет не требуется
	 */
	InvoicePlan recalculateOnPrematureClosing(LongTermInvoice invoice, Date closeDate);

	/**
	 * Пересчет инвойса при расширении привилегии. Может растянуть инвойс, определив новую планируемую дату завершения
	 * инвойса. Для определения новой плановой даты завершения применяется правило "минимальная дата из окнончания
	 * периода списания, окончания действия подписки (для срочных подписок), новой даты окончания привилегии".
	 * <p>
	 * Указанная привилегия должна быть применена к текущему инвойсу. Новая дата окончания привилегии должна превышать
	 * текущую планируемую дату завершения инвойса. Если новая дата завершения привилегии не изменилась и равна
	 * планируемой дате завершения иновойса, то пересчет не требуется и в качестве результата будет возвращен null
	 * <p>
	 * Состояние инвойса при пересчете не меняется. Для применения нового плана к инвойсу необходимо явно вызвать метод
	 * {@link LongTermInvoice#applyPlan(InvoicePlan)}. Пересчитать можно только открытый инвойс
	 * 
	 * @param invoice
	 *            - инвойс для пересчета
	 * @param privilege
	 *            - расширяемая привилегия
	 * 
	 * @return новый план. Или null, если пересчет не требуется
	 */
	InvoicePlan recalculateOnPrivilegeExpansion(LongTermInvoice invoice, Privilege privilege);

	/**
	 * Пересчет инвойса в случае, если необходимо учесть новую скидку, период которой пересекается с периодом инвойса.
	 * Предполагается, что указанной скидки еще нет в текущем инвойсе.
	 * <p>
	 * Состояние инвойса при пересчете не меняется. Для применения нового плана к инвойсу необходимо явно вызвать метод
	 * {@link LongTermInvoice#applyPlan(InvoicePlan)}. Пересчитать можно только открытый инвойс
	 * 
	 * @param invoice
	 *            - инвойс для пересчета
	 * @param discount
	 *            - добавляемая к инвойсу скидка
	 * 
	 * @return новый план. Всегда не null
	 */
	InvoicePlan recalculateOnAddingDiscount(LongTermInvoice invoice, Discount discount);

	/**
	 * Пересчет инвойса в случае, если необходимо удалить из него имеющуюся скидку.
	 * <p>
	 * Состояние инвойса при пересчете не меняется. Для применения нового плана к инвойсу необходимо явно вызвать метод
	 * {@link LongTermInvoice#applyPlan(InvoicePlan)}. Пересчитать можно только открытый инвойс
	 * 
	 * @param invoice
	 *            - инвойс для пересчета
	 * @param discount
	 *            - удаляемая из инвойса скидка
	 * 
	 * @return новый план. Всегда не null
	 */
	InvoicePlan recalculateOnRemovingDiscount(LongTermInvoice invoice, Discount discount);
}
