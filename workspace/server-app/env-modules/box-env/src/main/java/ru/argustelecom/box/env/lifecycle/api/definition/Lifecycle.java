package ru.argustelecom.box.env.lifecycle.api.definition;

import java.io.Serializable;
import java.util.Collection;

import ru.argustelecom.box.env.lifecycle.api.LifecycleObject;
import ru.argustelecom.box.env.lifecycle.api.LifecycleState;

/**
 * Жизненный цикл бизнес-объекта -- это конечный набор стадий, охватывающий состояния бизнес-объекта, начиная с момента
 * возникновения необходимости в этом объекте и заканчивая его выводом из эксплуатации. Другими словами, жизненный цикл
 * это конечный набор фаз или этапов, через которые бизнес-объект может проходить в течение своей истории жизни.
 * 
 * <p>
 * В течение своей жизни, бизнес-объект проходит через определенные для него этапы (состояния), при переходе в каждое
 * состояние могут выполняться различные проверки допустимости такого перехода (валидация, гарантирующая, что
 * бизнес-объект достиг всех результатов, запланированных для текущей стадии), а также бизнес-операции, обеспечивающие
 * консистентное представление этого объекта для внешней среды в его новом состоянии.
 * 
 * <p>
 * Жизненный цикл с математической точки зрения представляет собой ориентированный граф, где вершинами являются его
 * состояния (причем все варианты состояний должны быть достижимы, иначе такое недостижимое состояние не имеет смысла),
 * а ребрами -- переходы между этими состояниями.
 * 
 * <p>
 * Основные термины и определения жизненного цикла:
 * <ul>
 * <li>{@linkplain LifecycleRoute Маршрут}
 * <li>Основной маршрут - маршрут из конкретного состояния, который указан первым в декларации жизненного цикла.
 * Представляет собой наиболее вероятный маршрут, по которому скорее всего перейдет бизнес-объект. Всегда один или
 * отсутствует (в случае, если вообще нет никаких маршрутов, например, в конечном состоянии).
 * <li>Вторичные маршруты - все прочие маршруты, менее вероятные для перехода.
 * <li>"Запрещенное поведение" - жизненный цикл на определенных этапах может запрещать выполнение некоторых
 * бизнес-операций, например, блокировать изменение определенных атрибутов бизнес-объекта или блокировать выполнение
 * каких-либо операций. "Запрещенное поведение" с точки зрения жизненного цикла не содержит никакой предметной
 * составляющей и представленно в виде простого идентификатора, который должен интерпретироваться бизнес-кодом,
 * например, представлением бизнес-объекта в UI. В обязанности жизненного цикла входит только сохранение факта, что
 * поведение с указанным идентификатором запрещено на конкретной стадии жизненного цикла
 * </ul>
 * 
 * @param <S>
 *            - тип состояния бизнес-объекта жизненного цикла
 * @param <O>
 *            - тип бизнес-объекта жизненного цикла
 */
public interface Lifecycle<S extends LifecycleState<S>, O extends LifecycleObject<S>> {

	/**
	 * Возвращает уникальный идентификатор текущего жизненного цикла. Не может быть null или пустой строкой (если
	 * используются строковые идентификаторы)
	 */
	Serializable getKeyword();

	/**
	 * Возвращает наименование текущего жизненного цикла. Наименование должно быть понятно пользователю
	 */
	String getName();

	/**
	 * Возвращает вариант жизненного цикла, содержащий только те маршруты, которые разрешены для использования
	 * пользователем из специализированного UI.
	 */
	Lifecycle<S, O> controlledByUser();

	/**
	 * Проверяет, запрещено ли поведение с указанным идентификатором в указанном состоянии жизненного цикла.
	 * 
	 * @param state
	 *            - состояние жизненного цикла
	 * @param behavior
	 *            - идентификатор поведения
	 * 
	 * @return true, если поведение явно запрещено, во всех остальных случаях (в том числе, если это поведение никак не
	 *         регламентировалось на уровне декларации ЖЦ) возвращает false
	 */
	boolean isForbidden(S state, Serializable behavior);

	/**
	 * Проверяет, существуют ли маршруты из указанной начальной точки
	 * 
	 * @param startPoint
	 *            - начальная точка потенциального маршрута
	 * 
	 * @return true, если есть хотя бы один маршрут, начинающийся в указанной начальной точке
	 */
	boolean hasRoutes(S startPoint);

	/**
	 * Проверяет, существуют ли маршруты, по которым можно перейти из текущего состояния указанного бизнес-объекта
	 * 
	 * @param businessObject
	 *            - бизнес-объект, из текущего состояния которого проверяется наличие потенциального маршрута
	 * 
	 * @return true, если есть хотя бы один маршрут, начинающийся в текущем состоянии указанного бизнес-объекта
	 */
	default boolean hasRoutes(O businessObject) {
		return hasRoutes(businessObject.getState());
	}

	/**
	 * Возвращает коллекцию всех доступных маршрутов, начинающихся в указанной начальной точке
	 * 
	 * @param startPoint
	 *            - начальная точка потенциального маршрута
	 * 
	 * @return коллекцию потенциальных маршрутов или пустую коллекцию, если маршрутов, удовлетворяющих условию, нет
	 */
	Collection<LifecycleRoute<S, O>> getRoutes(S startPoint);

	/**
	 * Возвращает коллекцию всех доступных маршрутов, начинающихся в текущем состоянии указанного бизнес-объекта
	 * 
	 * @param businessObject
	 *            - бизнес-объект, из текущего состояния которого могут начинаться потенциальные маршруты
	 * 
	 * @return коллекцию потенциальных маршрутов или пустую коллекцию, если маршрутов, удовлетворяющих условию, нет
	 */
	default Collection<LifecycleRoute<S, O>> getRoutes(O businessObject) {
		return getRoutes(businessObject.getState());
	}

	/**
	 * Возвращает основной маршрут, начинающийся в указанном состоянии
	 * 
	 * @param startPoint
	 *            - начальная точка потенциального маршрута
	 * 
	 * @return основной маршрут или null, если из текущей начальной точки не начинается ни одного маршрута
	 */
	LifecycleRoute<S, O> getMainRoute(S startPoint);

	/**
	 * Возвращает основной маршрут, начинающийся в текущем состоянии указанного бизнес-объекта
	 * 
	 * @param businessObject
	 *            - бизнес-объект, из текущего состояния которого необходимо получить основной маршрут
	 * 
	 * @return основной маршрут или null, если из текущего состояния бизнес-объекта не начинается ни одного маршрута
	 */
	default LifecycleRoute<S, O> getMainRoute(O businessObject) {
		return getMainRoute(businessObject.getState());
	}

	/**
	 * Возвращает коллекцию всех доступных вторичных маршрутов, начинающихся в указанной начальной точке
	 * 
	 * @param startPoint
	 *            - начальная точка потенциальных вторичных маршрутов
	 * 
	 * @return коллекцию вторичных маршрутов или пустую коллекцию, если маршрутов нет или определен только основной
	 *         маршрут
	 */
	Collection<LifecycleRoute<S, O>> getSecondaryRoutes(S startPoint);

	/**
	 * Возвращает коллекцию всех доступных вторичных маршрутов, начинающихся в текущем состоянии указанного
	 * бизнес-объекта
	 * 
	 * @param businessObject
	 *            - бизнес-объект, из текущего состояния которого необходимо получить вторичные маршруты
	 * 
	 * @return коллекцию вторичных маршрутов или пустую коллекцию, если маршрутов нет или определен только основной
	 *         маршрут
	 */
	default Collection<LifecycleRoute<S, O>> getSecondaryRoutes(O businessObject) {
		return getSecondaryRoutes(businessObject.getState());
	}
}
