package ru.argustelecom.box.env.lifecycle.api;

import java.io.Serializable;
import java.util.Objects;

import com.google.common.base.Strings;

import ru.argustelecom.system.inf.modelbase.Identifiable;

/**
 * Описывает некоторый бизнес-объект, который может обладать жизненным циклом: состояниями (описывают этапы или стадии,
 * в которых объект находится в тот или иной момент времени) и правилами изменения этих состояний (действиями, которые
 * должны быть выполнены над объектом для того, чтобы можно было считать, что он изменил свое состояние, а также
 * проверками, которые гарантируют, что изменение состояния правомерно).
 * 
 * <p>
 * Если объект имеет несколько вариантов различных состояний и правила изменения этих состояний каким-либо образом
 * регламентированы (бизнес-требования, бизнес-логика), то с большой степенью вероятности этот объект должен
 * реализовывать текущий интерфейс, а его состояние должно меняться при помощи механизма жизненного цикла.
 * 
 * <p>
 * Объект жизненного цикла неразрывно связан со своим состоянием. Для одного типа объектов ЖЦ может быть указан только
 * один тип состояний этого объекта ЖЦ (например, для Subscription только SubscriptionState). При этом объект ЖЦ может
 * работать только со своими состояниями и не может работать с состояниями других бизнес-объектов (например,
 * Subscription на уровне компилляции не сможет пользоваться ContractState, даже случайно. Наоборот тоже верно).
 * 
 * <p>
 * Жизненный цикл представляет собой граф, где его вершинами являются состояния, а ребрами -- переходы между этими
 * состояниями
 * 
 * <p>
 * Объект жизненного цикла может быть как перситстентной сущностью, так и обычным POJO
 * 
 * @param <S>
 *            - тип состояния бизнес-объекта жизненного цикла
 * @param <O>
 *            - тип бизнес-объекта жизненного цикла
 */
public interface LifecycleObject<S extends LifecycleState<S>> extends Identifiable {

	/**
	 * Возвращает текущее состояние объекта жизненного цикла. Не может быть null.
	 * 
	 * @return состояние бизнес-объекта
	 */
	S getState();

	/**
	 * Устанавливает новое состояние объекта жизненного цикла. На текущий момент этот метод используется только в одном
	 * месте (lifecycle executor). По хорошему, нужно вынести этот метод из публичного интерфейса, т.к. открывая доступ
	 * к изменению состояния можно нарушить целостность всего механизма
	 * 
	 * @param state
	 *            - новое состояние БО
	 */
	void setState(S state);

	default boolean inState(S state) {
		return Objects.equals(getState(), state);
	}

	default boolean inState(Iterable<S> states) {
		for (S state : states) {
			if (inState(state)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Один и тот же тип бизнес-объекта может обладать несколькими жизненными циклами в зависимости от внешних условий
	 * или настроек системы. Этот метод возвращает уникальный квалификатор жизненного цикла, применимого к текущему
	 * бизнес-объекту. По этому квалификатору должно быть возможно однозначно определить жизненный цикл объекта в общем
	 * {@linkplain LifecycleRegistry реестре жизненных циклов}
	 * 
	 * <p>
	 * Serializable в качестве типа возвращаемого результата выбран не случайно - так мы можем поддержать не только
	 * строковые квалификаторы, но также enum или любой другой вид константы. Если для реализации квалификатора будет
	 * выбран тип, отличный от стандартных (String, Long, Enum), то тип квалификатора обязательно должен переопределить
	 * и правильно реализовать методы hashCode, equals, toString. В качестве результата toString должна возвращаться
	 * понятная читаемая строка, по которой потенциально из кода можно будет восстановить объект квалификатора. Эта
	 * строка непосредственно используется для сохранения соответствия типа жизненного цикла и типа объектов в
	 * {@linkplain LifecycleRegistry реестре жизненных циклов}
	 * 
	 * <p>
	 * Важно отметить, что тип самого объекта не меняется (например, Subscription), тип состояния тоже не меняется
	 * (SubscriptionState), но жизненных циклов может быть несколько (SubscriptionFullLifecycle,
	 * SubscriptionShortLifecycle). В данном конкретном случае для объекта типа подписка необходимо перекрыть этот метод
	 * и вернуть уникальный квалификатор жизненного цикла, по которому можно будет однозначно определить сеттинг ЖЦ.
	 * Аналогично необходимо поступать всякий раз, когда какой либо тип бизнес-объекта может обладать более чем одним
	 * ЖЦ.
	 * 
	 * @return значение квалификатора ЖЦ, по умолчанию null
	 */
	default Serializable getLifecycleQualifier() {
		return null;
	}

	/**
	 * Возвращает true, если бизнес-объект квалифицирует жизненный цикл. Не следует перекрывать этот метод
	 * 
	 * @return
	 */
	default boolean hasLifecycleQualifier() {
		Serializable qualifier = getLifecycleQualifier();
		if (qualifier instanceof String) {
			return !Strings.isNullOrEmpty((String) qualifier);
		}
		return qualifier != null;
	}
	
	default void onStateChanged(S from, S to) {
		// DO NOTHING
	}
}